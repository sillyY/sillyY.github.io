(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{299:function(t,n,a){"use strict";a.r(n);var e=a(9),r=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"手写-call-apply-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写-call-apply-bind","aria-hidden":"true"}},[t._v("#")]),t._v(" 手写 call-apply-bind")]),t._v(" "),a("h2",{attrs:{id:"引言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引言","aria-hidden":"true"}},[t._v("#")]),t._v(" 引言")]),t._v(" "),a("p",[t._v("call、apply 及 bind 这三个方法，对于新手而言，基本不知道怎么去用，或许就知道改变 this 指向这个知识。但往往在面试中，call,apply 及 bind 的作用会常常被问及。所以我们现在全面分析下这三者。")]),t._v(" "),a("h2",{attrs:{id:"bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind","aria-hidden":"true"}},[t._v("#")]),t._v(" bind")]),t._v(" "),a("h3",{attrs:{id:"描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述","aria-hidden":"true"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),a("p",[t._v("首先我们引入下 MDN 关于"),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind",target:"_blank",rel:"noopener noreferrer"}},[t._v("Function.prototype.bind()"),a("OutboundLink")],1),t._v("的描述")]),t._v(" "),a("blockquote",[a("p",[t._v("bind() 函数会创建一个新绑定函数（bound function，BF）。绑定函数是一个 exotic function object（怪异函数对象，ECMAScript 2015 中的术语），它包装了原函数对象。调用绑定函数通常会导致执行包装函数。")])]),t._v(" "),a("p",[t._v("通俗来说，返回一个改变了 this 指向的函数")]),t._v(" "),a("h3",{attrs:{id:"手写-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写-bind","aria-hidden":"true"}},[t._v("#")]),t._v(" 手写 bind")]),t._v(" "),a("p",[t._v("其实这里存在一个问题，如果原函数是一个构造函数，那么我们也得保证 bind 之后的函数也是构造函数")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Function.prototype.myBind = function(context) {\n    // 保存原this指向，myBind后续参数\n    const that = this,\n        args = Array.prototype.slice.call(arguments, 1)\n\n    // 首先检验this是不是个函数, this指代原函数\n    if(typeof this !== 'function') {\n        throw new TypeError(`${this} is not a function`)\n    }\n\n    // 返回函数\n    return function F() {\n        // 判断是否是F的实例，从而判断原函数是否构造函数，后续会带例子分析\n        // new 下 原构造函数，并把结果返回\n        if(this instanceof F) return new that(...args, ...arguments)\n        // 普通函数，即正常运行\n        return that.apply(context, args.concat(...arguments))\n    }\n}\n")])])]),a("h3",{attrs:{id:"分析-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分析-bind","aria-hidden":"true"}},[t._v("#")]),t._v(" 分析 bind")]),t._v(" "),a("p",[t._v("下面用例子来分析一下，构造函数下 bind 的运行过程，省略普通函数。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Person(name) {\n    this.name = name;\n}\nvar person = new Person('小明') // 正常实例化构造函数\n\n// step 1\nvar P = Person.myBind(this)\n// step 2\nvar p = new P('小李')\n")])])]),a("ul",[a("li",[t._v("1.执行 step1\n这里先把 myBind 看做普通函数，执行下 Person.myBind，返回下面的结果，即构造函数 F")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function F() {\n        // 判断是否是F的实例，从而判断原函数是否构造函数\n        // new 下 原构造函数，并把结果返回\n        if(this instanceof F) return new that(...args, ...arguments)\n        // 普通函数，即正常运行\n        return that.apply(context, args.concat(...arguments))\n    }\n")])])]),a("ul",[a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("执行 step2"),a("br"),t._v("\n这里就相当于执行构造函数 F, 也就是实例化一个构造函数。"),a("br"),t._v("\n所以在函数内部可以通过"),a("code",[t._v("this instanceof F")]),t._v("来判断是否是构造函数, 这里的 this 指代实例化出来的对象 "),a("code",[t._v("F {}")]),a("br"),t._v("\n也就可以 new 原构造函数， 这里 that 指代 Person 函数")])])])]),t._v(" "),a("h2",{attrs:{id:"call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call","aria-hidden":"true"}},[t._v("#")]),t._v(" call")]),t._v(" "),a("h3",{attrs:{id:"描述-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述-2","aria-hidden":"true"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call",target:"_blank",rel:"noopener noreferrer"}},[t._v("Function.prototype.call()"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("call() 允许为不同的对象分配和调用属于一个对象的函数/方法。")]),t._v(" "),a("p",[t._v("call() 提供新的 this 值给当前调用的函数/方法。你可以使用 call 来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。")]),t._v(" "),a("h3",{attrs:{id:"手写-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写-call","aria-hidden":"true"}},[t._v("#")]),t._v(" 手写 call")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" Function.prototype.myCall = function(context) {\n    let result;\n    const args = [...arguments].slice(1)\n\n     // 首先检验this是不是个函数, this指代原函数\n    if(typeof this !== 'function') {\n        throw new TypeError(`${this} is not a function`)\n    }\n\n    // context 初始化，以及将原函数赋值到其fn属性上\n    // ps： context指代上下文对象\n    context = context || window\n    context.fn = this;\n\n    // 执行content的fn\n    result = context.fn(args)\n\n    // 删除context上本不存在的fn\n    delete context.fn\n\n    // 返回结果\n    return result\n }\n")])])]),a("h2",{attrs:{id:"apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#apply","aria-hidden":"true"}},[t._v("#")]),t._v(" apply")]),t._v(" "),a("h3",{attrs:{id:"描述-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述-3","aria-hidden":"true"}},[t._v("#")]),t._v(" 描述")]),t._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply",target:"_blank",rel:"noopener noreferrer"}},[t._v("Function.prototype.apply"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。")]),t._v(" "),a("h3",{attrs:{id:"手写-apply"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写-apply","aria-hidden":"true"}},[t._v("#")]),t._v(" 手写 apply")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" Function.prototype.myCall = function(context) {\n    let result;\n\n     // 首先检验this是不是个函数, this指代原函数\n    if(typeof this !== 'function') {\n        throw new TypeError(`${this} is not a function`)\n    }\n\n    // context 初始化，以及将原函数赋值到其fn属性上\n    // ps： context指代上下文对象\n    context = context || window\n    context.fn = this;\n\n    // 如果第二个参数（数组）存在\n    // 带参数执行 : 无参数执行\n    result = arguments[1] ? context.fn(...arguments[1]) : content.fn()\n\n    // 删除context上本不存在的fn\n    delete context.fn\n\n    // 返回结果\n    return result\n }\n")])])]),a("Valine")],1)}),[],!1,null,null,null);n.default=r.exports}}]);